% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\author{}
\date{}

\usepackage{amsmath,amssymb}
\usepackage{booktabs}
\usepackage{lmodern}
\usepackage{iftex}
\usepackage{siunitx}
\usepackage{pgfplots}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available

\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\usepackage[
    backend=biber,
    style=ieee,
    citestyle=ieee,
    % defernumbers=true
]{biblatex}
\addbibresource{pascal.bib}

\usepackage{hyperref}
\usepackage{cleveref}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX}}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi


\begin{document}

\section{Encoder Implementation}\label{encoder-implementation}

Existing literature~\cite{Lengerke2022,Lengerke2023,Ferrara2022} has developed reed-salomon (RS) codes as an ID
code with great statistical properties. However, the encoding time of
the surveyed RS implementations is orders of magnitude slower than industry standard hashing functions like Sha2~\cite{Lengerke2022,Ferrara2022}. As a result practical applications are limited.

\cite{Ferrara2022} demonstrates significantly improved encoding speeds by using binary extension fields. However, the presented implementation only reached speeds of $10Mbits/s = 1.22MiB/s$. Those speeds are still far slower than Sha2 which can reach speeds of $2.25GiB/s$ (see \cref{sec:bench}). Furthermore, the presented speed implementation is limited to a small field size of $2^{8}$ which significantly limits the world size. Henceforth, an alternative encoder implementation is described which can reach similar throughput as Sha2 while also allowing significantly larger fields/world sizes.

An RS encoder operates on a list of symbols \(s_i\). These symbols are
elements of finite field \(s_i \in GF(n)\). The resulting RS code
(usually) has \(n - 1\) symbols \(r_j\) that are obtained by multiplying
each element with a power of the fields' generator \(a\). A generator
\(a \in GF(n)\) is a finite field element whose powers
 are all unique \(a^i \neq a^j \quad 0 \le i, j \le n - 1\). The symbols of the RS
code can be calculated with

\begin{equation}
r_j = \sum_{i=0}^{n - 1} s_i a^{j i}.
\end{equation}

For an ID code only one (random) symbol $r_j$ needs to be computed.

 In literature prime fields are usually used for RS-ID encoders~\cite{Lengerke2022,Lengerke2023}. These
are fields where \(n\) is a prime number. These fields are isomorphic to
the ring of integers modulus \(n\): \(GF(n) \cong \mathbb{Z} / n\mathbb{Z}\).
Therefore, multiplication is fairly fast as the CPU can just perform
normal integer multiplication and calculate the remainder afterwards (so
multiplication is only twice as slow as normal multiplication). However,
computer memory is encoded as bytes. Converting that memory to prime requires treating that memory as  variable sized integer and performing a radix conversion. This conversion essentially involves repeated division/remainder calculation. As big integer division has linear time complexity $O(N)$, this radix conversion has time complexity of \(O(n^2)\) (with a high time factor).

\newpage
\subsection{(Binary) Extension Field
Construction}\label{binary-extension-field-construction}

Other established applications of RS encoding (and finite fields in
general) such as RAID-6 therefore use (binary) extension fields instead. This approach is also used in~\cite{Ferrara2022}.
Extension fields are finite fields with the cardinality of a prime power
\(n = p^z\). The elements of such a field are polynomials of degree
\(z - 1\) with coefficients in its base prime field:

\begin{equation}
b = b_{z - 1} x^{z - 1} + .. + b_1 x + b_0 \quad b \in GF(p^z), b_i \in GF(p).
\end{equation}

Addition/Subtraction of polynomials is simply performed element wise.
For binary extension fields in particular both addition and subtraction
are equivalent to XOR. Polynomial multiplication can create
elements outside the finite field. For example:

\begin{equation}
x^{2z - 2} = x^{z - 1} x^{z - 1} \notin GF(p^z).
\end{equation}

To construct an extension field it is necessary to select an irreducible
rank \(z\) polynomial \(P\). Multiplication in
the extension field is then defined as polynomial multiplication modulus
\(P\). A field constructed this way retains all properties of prime
fields.

Binary extension fields (\(p = 2\)) are of particular interest because
their elements can be represented by binary numbers of length \(z\). If
z is a (power of two) multiple of 8 then symbols correspond to
bytes/words which can be read directly from memory without additional
overhead (and are well suited for processing with CPU instructions).

\subsection{Binary Extension Field
Implementation}\label{binary-extension-field-implementation}

As previously mentioned addition and subtraction of binary extension
fields can be implemented using a XOR. For small fields ($GF(2^{8}$) and
$GF(2^{16})$)  multiplication can be implemented using a lookup table (LUT). Here the
g2p~\cite{Wanzenbock} library was used. However, an LUT based apporach become impractically
large for higher \(z\) (like $GF(2^{32})$) as it has a space complexity of $O(n^2)$.

Efficient multiplication of 32bit and 64bit finite fields can be implemented using
carryless multiply instruction sets insted. These instructions are available on all amd64 CPUs released since 2011 and on all aarch64 CPUs. Carryless
multiply (CLMU) instructions perform a simple polynomial multiplication
(without a modulus) as described in~\cref{binary-extension-field-construction}. The 32/64
bit modulus of the resulting 64/128 bit polynomial can be computed by
utilizing the CLMU instruction to perform a barrett reduction as
described in~\cite{Dixon2009}. A practical
implementation is slightly more involved as implementing the bit
shuffling can be complex. An implementation of a 32 bit for amd64 is shown below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn}\NormalTok{ barrett\_reduce(x}\OperatorTok{:} \NormalTok{\_\_m128i) }\OperatorTok{{-}\textgreater{}} \DataTypeTok{u32} \OperatorTok{\{}
    \KeywordTok{let}\NormalTok{ pu }\OperatorTok{=} \NormalTok{\_mm\_set\_epi64x(U\_PRIME}\OperatorTok{,}\NormalTok{ P\_X)}\OperatorTok{;}
    \KeywordTok{let}\NormalTok{ t1 }\OperatorTok{=} \NormalTok{\_mm\_clmulepi64\_si128(}
        \NormalTok{\_mm\_and\_si128(x}\OperatorTok{,} \NormalTok{\_mm\_set\_epi32(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \OperatorTok{!}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\NormalTok{))}\OperatorTok{,}
\NormalTok{        pu}\OperatorTok{,}
        \DecValTok{0x10}\OperatorTok{,}
\NormalTok{    )}\OperatorTok{;}
    \KeywordTok{let}\NormalTok{ t2 }\OperatorTok{=} \NormalTok{\_mm\_clmulepi64\_si128(}
        \NormalTok{\_mm\_and\_si128(t1}\OperatorTok{,} \NormalTok{\_mm\_set\_epi32(}\DecValTok{0}\OperatorTok{,} \OperatorTok{!}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\NormalTok{))}\OperatorTok{,}
\NormalTok{        pu}\OperatorTok{,}
        \DecValTok{0x01}\OperatorTok{,}
\NormalTok{    )}\OperatorTok{;}

    \KeywordTok{let}\NormalTok{ tmp }\OperatorTok{=} \NormalTok{\_mm\_extract\_epi32(t2}\OperatorTok{,} \DecValTok{0}\NormalTok{) }\KeywordTok{as} \DataTypeTok{u32}\OperatorTok{;}
    \KeywordTok{let}\NormalTok{ x }\OperatorTok{=} \NormalTok{\_mm\_extract\_epi32(x}\OperatorTok{,} \DecValTok{0}\NormalTok{) }\KeywordTok{as} \DataTypeTok{u32}\OperatorTok{;}

\NormalTok{    tmp }\OperatorTok{\^{}}\NormalTok{ x}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Computing powers by naively repeating multiplication is very slow.
Instead, the square-and-multiply implementation from the g2p library~\cite{Wanzenbock} is used here. The performance of the implementation isn't critical as an
efficient RS-ID encoder only needs to compute a single power (see \cref{simple-rs-id-encoder-implementation}).

\subsection{Simple RS-ID encoder
implementation}\label{simple-rs-id-encoder-implementation}

For a binary extension field \(GF(2^z)\) where \(z=8*2^l\) the input
symbols can simply directly read from memory (assuming its sufficiently
aligned). If T is an integer with the size of the symbol then such a RS
encoder can be implemented as follows (all arithmetic is performed in
the finite field):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn}\NormalTok{ encode\_rs(data}\OperatorTok{:} \OperatorTok{\&}\NormalTok{[T]}\OperatorTok{,}\NormalTok{ cue}\OperatorTok{:} \DataTypeTok{usize}\NormalTok{) }\OperatorTok{{-}\textgreater{}}\NormalTok{ T }\OperatorTok{\{}
    \KeywordTok{if}\NormalTok{ data}\OperatorTok{.}\NormalTok{is\_empty() }\OperatorTok{\{}
        \KeywordTok{return}\NormalTok{ zero()}\OperatorTok{;}
    \OperatorTok{\}}
    \KeywordTok{let} \KeywordTok{mut}\NormalTok{ res }\OperatorTok{=}\NormalTok{ data[}\DecValTok{0}\NormalTok{]}\OperatorTok{;}
    \KeywordTok{let}\NormalTok{ initial\_generator }\OperatorTok{=}\NormalTok{ GENERATOR}\OperatorTok{.}\NormalTok{pow(cue)}\OperatorTok{;}
    \KeywordTok{let} \KeywordTok{mut}\NormalTok{ generator }\OperatorTok{=}\NormalTok{ initial\_generator}\OperatorTok{;}
    \KeywordTok{for}\NormalTok{ symbol }\KeywordTok{in}\NormalTok{ data[}\DecValTok{1}\OperatorTok{..}\NormalTok{] }\OperatorTok{\{}
\NormalTok{        res }\OperatorTok{+=}\NormalTok{ generator }\OperatorTok{*}\NormalTok{ symbol}\OperatorTok{;}
\NormalTok{        generator }\OperatorTok{*=}\NormalTok{ initial\_generator}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    res}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\pagebreak
Compared to a more naive implementation the input data is not zero
padded. For the zero symbol \(s_i a^{j i} = 0\) always holds. The zero
padded symbols therefore never contribute anything to the final sum.
Furthermore, the generator power is not recomputed in each loop
iteration. Instead, the generator power for the next iteration is
calculated at the end of every iteration:
\(a^{j (i + 1)} = a^{j i} a^{j}\). This optimization alone allowed a
speedup by a factor of 64.

\subsection{Optimized 32 bit and 64 RS-ID encoder
implementation}\label{optimized-32-bit-rs-id-encoder-implementation}

CPUs usually only implement a single 64 bit CLMU instruction with a 128
bit output register. This fact can be used to optimize the 32 bit and 64 bit RS
encoder even further. The barrett reduction introduced in~\cite{Dixon2009}
requires two CLMU instructions and many additional instructions for bit
shuffling and is therefore much slower than the main CLMU.

The distributive and associative properties of the modulus
operation~\cite{Dixon2009} shown in \eqref{eq:modmul} and \eqref{eq:modsum} can be used to avoid almost all barrett reductions and therefore significantly speed up the encoder.
  
\begin{gather}
\begin{gathered}
(f \mod P) \otimes (g \mod P) \mod P = f \otimes (g \mod P) \mod P\\
= (f \mod P) \otimes g \mod P = f \otimes g \mod P\\
\end{gathered}\label{eq:modmul}\\
\begin{gathered}
(f \mod P) \oplus (g  \mod P) \mod P = f \oplus (g \mod P) \mod P\\
 = (f \mod P) \oplus g \mod P = f \oplus g \mod P\label{eq:modsum}
\end{gathered}
\end{gather}

Note that \eqref{eq:modmul} only holds on hardware as long as the register is large enough
to hold the result. That means that at most three 32bit elements and two 64 bit elements can be
multiplied before a reduction is necessary. However, an unlimited number
of elements can be added without requiring reduction as polynomial addition cannot overflow. Therefore, all products of the RS computation can be summed without performing a barrett
reduction. Only a single barrett reduction of the final sum is necessary.

However, the exponent of the generator \(a^{ji + 1} = a^{ji} a^j\) still
requires a barrett reduction for every element as the product would
quickly exceed the register size. The cost of this barrett reduction can
be amortized by splitting input symbols into shards of
length \(m\) that are encoded individually:

\begin{gather}
R_{j,k} = \sum_l^m a^{jl} s_{k*m+l}\\
r_j = \sum_k^{n/m} R_{j,k} a^{jkm}.
\end{gather}

The coefficients \(a^{jl}\) can be precomputed and stored in a LUT at
the start of the encoding. As a result the inner encoder loop only
consists of a single CLMU instruction\footnote{and memory access to access symbols/LUT}. A barrett reduction to calculate \(a^{jm(k + 1)} = a^{jkm} a^{jm}\) is only necessary every
$m$ symbols.

Therefore, this optimized encoder only requires \(O(n + n/m + m)\)
CLMU instructions. Theoretically \(m = \sqrt{n}\) would result in
minimal instruction count. However, measurements show no measurable
differences for a sufficiently large LUT (4096 elements) at larger
\(n\). The LUT size is therefore bounded to avoid (potentially
significant) additional memory consumption. The final algorithm is shown
below.

\vfill
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fn}\NormalTok{ encode\_rs(data}\OperatorTok{:} \OperatorTok{\&}\NormalTok{[}\DataTypeTok{u32}\NormalTok{]}\OperatorTok{,}\NormalTok{ cue}\OperatorTok{:} \DataTypeTok{usize}\NormalTok{) }\OperatorTok{{-}\textgreater{}}\NormalTok{ u32 }\OperatorTok{\{}
    \KeywordTok{if}\NormalTok{ data}\OperatorTok{.}\NormalTok{is\_empty() }\OperatorTok{\{}
        \KeywordTok{return}\DecValTok{ 0}\OperatorTok{;}
    \OperatorTok{\}}
    \KeywordTok{let} \KeywordTok{mut}\NormalTok{ res }\OperatorTok{=}\NormalTok{ data[}\DecValTok{0}\NormalTok{]}\OperatorTok{;}
    \KeywordTok{let}\NormalTok{ initial\_generator }\OperatorTok{=} \NormalTok{GENERATOR}\OperatorTok{.}\NormalTok{pow(cue)}\OperatorTok{;}
    \KeywordTok{let} \KeywordTok{mut}\NormalTok{ generator }\OperatorTok{=}\NormalTok{ initial\_generator}\OperatorTok{;}
    \KeywordTok{let} \KeywordTok{mut}\NormalTok{ lut }\OperatorTok{=} \PreprocessorTok{vec!}\NormalTok{[generator}\OperatorTok{;}\NormalTok{ ((data}\OperatorTok{.}\NormalTok{len() }\KeywordTok{as} \DataTypeTok{f64}\NormalTok{)}\OperatorTok{.}\NormalTok{sqrt() }\KeywordTok{as} \DataTypeTok{usize}\NormalTok{)}\OperatorTok{.}\NormalTok{min(}\DecValTok{4096}\NormalTok{)}\NormalTok{]}\OperatorTok{;}
    \KeywordTok{if} \OperatorTok{!}\NormalTok{lut}\OperatorTok{.}\NormalTok{is\_empty() }\OperatorTok{\{}
        \KeywordTok{for}\NormalTok{ entry }\KeywordTok{in} \OperatorTok{\&}\KeywordTok{mut}\NormalTok{ lut[}\DecValTok{1}\OperatorTok{..}\NormalTok{] }\OperatorTok{\{}
            \OperatorTok{*}\NormalTok{entry }\OperatorTok{=}\NormalTok{ generator}\OperatorTok{.}\NormalTok{mul(initial\_generator)}\OperatorTok{;}
\NormalTok{            generator }\OperatorTok{=} \OperatorTok{*}\NormalTok{entry}\OperatorTok{;}
        \OperatorTok{\}}
\NormalTok{        res }\OperatorTok{+=}\NormalTok{ data[}\DecValTok{1}\NormalTok{] }\OperatorTok{*}\NormalTok{ initial\_generator}\OperatorTok{;}
\NormalTok{        generator }\OperatorTok{=}\NormalTok{ initial\_generator}\OperatorTok{;}
        \KeywordTok{for}\NormalTok{ chunk }\KeywordTok{in}\NormalTok{ data[}\DecValTok{2}\OperatorTok{..}\NormalTok{]}\OperatorTok{.}\NormalTok{chunks(lut}\OperatorTok{.}\NormalTok{len()) }\OperatorTok{\{}
            \KeywordTok{let} \KeywordTok{mut}\NormalTok{ chunk\_sum }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
            \KeywordTok{for}\NormalTok{ (}\OperatorTok{\&}\NormalTok{sym}\OperatorTok{,} \OperatorTok{\&}\NormalTok{generator\_pow) }\KeywordTok{in}\NormalTok{ chunk}\OperatorTok{.}\NormalTok{iter()}\OperatorTok{.}\NormalTok{zip(}\OperatorTok{\&}\NormalTok{lut) }\OperatorTok{\{}
\NormalTok{                chunk\_sum }\OperatorTok{+=}\NormalTok{ sym }\OperatorTok{*}\NormalTok{ generator\_pow}\OperatorTok{;}
            \OperatorTok{\}}
\NormalTok{            res }\OperatorTok{+=}\NormalTok{ chunk\_sum }\OperatorTok{*}\NormalTok{ generator}\OperatorTok{;}
\NormalTok{            generator }\OperatorTok{=}\NormalTok{ generator }\OperatorTok{*}\NormalTok{ (}\OperatorTok{*}\NormalTok{lut}\OperatorTok{.}\NormalTok{last()}\OperatorTok{.}\NormalTok{unwrap())}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}
\NormalTok{    res}\OperatorTok{.}\NormalTok{reduce()}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\vfill

\newpage

\section{Benchmarks}
\label{sec:bench}

All measurements were performed on an AMD Ryzen 9 5950X processor. The statistic distribution of measured encoding times are shown in~\cref{fig:bench_dist} for a single benchmark. Other benchmarks show similar distributions and are therefore not shown here. The average encoding time and throughput are visualized as a function of message/world size in \cref{fig:bench_time,fig:bench_throughput}. The message/world size $d=\frac{8k}{2^z}$ was used instead of $k$ to ensure all encoders are comparable.


The simple RS encoder introduced in \cref{simple-rs-id-encoder-implementation} was benchmarked for $GF(2^8)$, $GF(2^{16})$ (lookup table), $GF(2^{32})$ and $GF(2^{64})$ (CLMU instructions). The optimized RS encoders described in \cref{optimized-32-bit-rs-id-encoder-implementation} were benchmarked for $GF(2^{32})$ and $GF(2^{64})$. 

Sha224 was also included as a baseline. The encoder uses dedicated hardware for Sha2 available on modern amd64 processors. The measured throughput is approximately $2.25GiB/s$. Because Sha224 always accepts arbitrary bytes and produces a 224 bit output the symbol size has no relevance and the throughput is fairly constant only exhibiting a small drop at very small message/world size. 

The simple RS encoders show roughly constant throughput between $200MiB/s$ and $500MiB/s$. For the LUT based approach smaller fields perform better as the table is smaller and can be indexed faster. For CLMU based field implementations larger fields have higher throughput as more data can be processed with a single instruction. 

The throughput of the optimized RS encoders at small $k$ decreases as the overhead of computing the LUT becomes significant. This is especially relevant for the $GF(2^{64})$ encoder as $k$ is smaller by a factor of two for the same world/message size. Around $10 KiB$ that overhead loses relevance and the throughput remains constant. The throughput measured for $GF(2^{64})$ is between $2.25 GiB/s$ and $3.45 GiB/s$ and therefore always faster than Sha224. The  $GF(2^{32})$ implementation is again about $50\%$ slower. 

\begin{figure}
\input{time.tex}
\input{troughput.tex}
\end{figure}
\begin{figure}
\input{deviation.tex}
\end{figure}
\newpage

\section{Conclusion and Outlook}

The presented optimized 32 bit and 64 bit RS encoder can reach speeds similar to Sha224 while simultaneously allowing much larger message/world sizes. This makes RS encoders viable for practical used.

The approach presented here is of particular interest to embedded use cases and custom hardware. A carryless multiplication can be implemented more easily and with less area requirements compared to a dedicated Sha2 encoder. Even compared to a conventional multiplier less area is required as all adders can be replaced with simple XOR gates. An existing multiplier  could even be reused by adding a flag that controls whether carrys are considered.

Future work could focus on also accelerating smaller symbol sizes like 8 bit and 16 bit with CLMU instructions. To that end multiple 8bit/16bit multiplications could be performed with a single (64bit) CLMU instruction. The use of smaller symbol sizes would further reduce network traffic at he cost of increased collision rate. 

Furthermore, future work  could investigate the impact of the chosen modulus polynomial on false positive rates. Exiting literature has established the choice of modulus polynomial affects how often and what kind of errors are detected~\cite{Jones2009}. Similar concerns likely apply to RS-ID codes too.

\printbibliography
\end{document}
